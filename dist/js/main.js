'use strict';

// spaghetti code hihii

import {Editor} from "./editor.js";
import * as Constructions from "./constructions.js";


const app = new PIXI.Application({
    width: 900, height: 600, backgroundColor: 0x1d1d1d, resolution: window.devicePixelRatio || 1, autoResize: true,
    antialias: true
});
document.getElementById("canvas").appendChild(app.view);
app.view.addEventListener('contextmenu', (e) => {
    e.preventDefault();
});


const editor = new Editor(app);

let selected = Constructions.Road;
let gui_sel = document.getElementById('gui-selection');
let constructs = [Constructions.Road, Constructions.Extension, Constructions.Wall, Constructions.Tower, Constructions.Terminal, Constructions.Storage, Constructions.Spawn, Constructions.Link, Constructions.Lab];
for (let i = 0; i < constructs.length; i++) {
    let construct = constructs[i];
    let elm = document.createElement('a');
    elm.href = '#';
    elm.id = construct.type;
    elm.innerHTML = construct.name;

    gui_sel.append(elm);
    elm.onclick = (e) => {
        selected = construct;
    };
}

app.stage.interactive = true;
app.renderer.plugins.interaction.on("mousedown", function(e) {
    if (!editor.isInMode()) {
        let click = e.data.originalEvent.which;
        if (click === 1) {
            let mouse_grid_x = Math.floor(editor.stage.toLocal(app.renderer.plugins.interaction.mouse.global).x / editor.GRID_BOX_SIZE) * editor.GRID_BOX_SIZE,
                mouse_grid_y = Math.floor(editor.stage.toLocal(app.renderer.plugins.interaction.mouse.global).y / editor.GRID_BOX_SIZE) * editor.GRID_BOX_SIZE;

            let c = new selected(editor);
            c.position.x = mouse_grid_x;
            c.position.y = mouse_grid_y;
            editor.add(c);
            //c.onDragStart(e);
        }
    }
});

let generateCode = (editor) => {
    let variableNames = ["blueprint", "blueprint_of_doom", "blueprint42", "your_blueprint", "blueprint_X"];
    let variable = variableNames[Math.floor(Math.random() * variableNames.length)];

    let content = "//Generated by BlueScreeps 1.0.0\r\nlet " + variable + " = (room_, x, y) => _.each([";
    let breakAfter = 5;

    for (let i in editor.instances) {
        let construct = editor.instances[i];
        if (construct instanceof Constructions.Construction) {
            if (i % breakAfter === 0 && parseInt(i) !== 0 && parseInt(i) !== editor.instances.length-1)
                content += "\r\n";
            let {x, y} = editor.getGridPos(construct.position.x, construct.position.y);
            content += "[" + construct.type + ", " + x / editor.GRID_BOX_SIZE + ", " + y / editor.GRID_BOX_SIZE + "], ";
        }
    }
    if (editor.instances.length > 0)
        content = content.slice(0, content.length - 2);
    content += "], (s) => {room_.createConstructionSite(x+s[1], y+s[2], s[0]);});\r\n\r\nmodule.exports = {" + variable + "};";

    return content;
};

let downloadButton = document.getElementById('downloadButton');
downloadButton.onclick = (e) => {
    e.stopPropagation();

    let content = generateCode(editor);

    let code = document.getElementById('code');
    code.innerHTML = content;
    Prism.highlightElement(code);

    //downloadButton.setAttribute('href', 'data:text/javascript;charset=utf-8,' + encodeURIComponent(content));
    //downloadButton.setAttribute('download', 'room.txt');
};

window.onload = (e) => {
    let content = generateCode(editor);

    let code = document.getElementById('code');
    code.innerHTML = content;
    Prism.highlightElement(code);
};

let clearButton = document.getElementById('clearButton');
clearButton.onclick = (e) => {
    e.stopPropagation();

    let instances = editor.instances.slice();
    for (let i = 0; i < instances.length; i++) {
        let construct = instances[i];
        editor.remove(construct);
    }

};



// TODO Test
class RoadDrawer {
    constructor(editor) {
        this.editor = editor;
        this.roads = new PIXI.Graphics();
        this.walls = new PIXI.Graphics();
        editor.stage.addChild(this.roads);
        editor.stage.addChild(this.walls);
    }
    update() {

        this.roads.clear();
        this.walls.clear();

        let instances = this.editor.instances;

        for (let i = 0; i < instances.length; i++) {
            if (instances[i] instanceof Constructions.Wall) {
                let c1 = instances[i];
                c1.neighbor = {top:false, bottom:false, left:false, right:false};
                for (let j = 0; j < instances.length; j++) {
                    if (instances[j] instanceof Constructions.Wall) {
                        let c2 = instances[j];
                        if ((c2.position.y + 32) === c1.position.y && c2.position.x === c1.position.x)
                            c1.neighbor.top = true;
                        if ((c2.position.y - 32) === c1.position.y && c2.position.x === c1.position.x)
                            c1.neighbor.bottom = true;
                        if ((c2.position.x - 32) === c1.position.x && c2.position.y === c1.position.y)
                            c1.neighbor.right = true;
                        if ((c2.position.x + 32) === c1.position.x && c2.position.y === c1.position.y)
                            c1.neighbor.left = true;
                    }
                }
            }

            if (instances[i] instanceof Constructions.Road) {
                let c1 = instances[i];
                c1.neighbor = {top:false, bottom:false, left:false, right:false, topright:false, topleft:false, bottomright:false, bottomleft:false};
                for (let j = 0; j < instances.length; j++) {
                     if (instances[j] instanceof Constructions.Road) {
                        let c2 = instances[j];
                        if ((c2.position.y + 32) === c1.position.y && c2.position.x === c1.position.x)
                            c1.neighbor.top = true;
                        if ((c2.position.y - 32) === c1.position.y && c2.position.x === c1.position.x)
                            c1.neighbor.bottom = true;
                        if ((c2.position.x - 32) === c1.position.x && c2.position.y === c1.position.y)
                            c1.neighbor.right = true;
                        if ((c2.position.x + 32) === c1.position.x && c2.position.y === c1.position.y)
                            c1.neighbor.left = true;

                        if ((c2.position.y + 32) === c1.position.y && (c2.position.x - 32) === c1.position.x)
                            c1.neighbor.topright = true;
                        if ((c2.position.y + 32) === c1.position.y && (c2.position.x + 32) === c1.position.x)
                            c1.neighbor.topleft = true;
                        if ((c2.position.y - 32) === c1.position.y && (c2.position.x + 32) === c1.position.x)
                            c1.neighbor.bottomleft = true;
                        if ((c2.position.y - 32) === c1.position.y && (c2.position.x - 32) === c1.position.x)
                            c1.neighbor.bottomright= true;
                    }
                }
            }
        }

        this.roads.beginFill('0x828282');
        this.roads.lineStyle(12, 0x828282, 1);
        
        for (let i = 0; i < instances.length; i++) {
            let construct = instances[i];

            if (construct instanceof Constructions.Road) {
                this.roads.lineStyle(0, 0x828282, 1);
                this.roads.drawCircle(construct.position.x + 16, construct.position.y + 16, 4);

                this.roads.lineStyle(8, 0x828282, 1);
                if (construct.neighbor.top) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x + 16, construct.position.y);
                }
                if (construct.neighbor.right) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x + 32, construct.position.y + 16);
                }
                if (construct.neighbor.bottom) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x + 16, construct.position.y + 32);
                }
                if (construct.neighbor.left) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x, construct.position.y + 16);
                }

                if (construct.neighbor.topright) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x + 32, construct.position.y);
                }

                if (construct.neighbor.topleft) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x, construct.position.y);
                }

                if (construct.neighbor.bottomright) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x + 32, construct.position.y + 32);
                }

                if (construct.neighbor.bottomleft) {
                    this.roads.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.roads.lineTo(construct.position.x, construct.position.y + 32);
                }

            }

            this.walls.beginFill(0x0b0b0b);
            if (construct instanceof Constructions.Wall) {
                this.walls.lineStyle(0, 0x0b0b0b, 1);
                this.walls.drawCircle(construct.position.x + 16, construct.position.y + 16, 16);

                this.walls.lineStyle(32, 0x0b0b0b, 1);
                if (construct.neighbor.top) {
                    this.walls.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.walls.lineTo(construct.position.x + 16, construct.position.y);
                }
                if (construct.neighbor.right) {
                    this.walls.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.walls.lineTo(construct.position.x + 32, construct.position.y + 16);
                }
                if (construct.neighbor.bottom) {
                    this.walls.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.walls.lineTo(construct.position.x + 16, construct.position.y + 32);
                }
                if (construct.neighbor.left) {
                    this.walls.moveTo(construct.position.x + 16, construct.position.y + 16);
                    this.walls.lineTo(construct.position.x, construct.position.y + 16);
                }

            }

        }
        this.walls.endFill();
        this.walls.updateTransform();
        this.roads.endFill();
        this.roads.updateTransform();
    }
}

let roadDrawer = new RoadDrawer(editor);
editor.on('update', () => {
    roadDrawer.update();
});